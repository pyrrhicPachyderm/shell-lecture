\documentclass[pdf,usenames,dvipsnames,14pt]{beamer}%usenames and dvipsnames are for colours.
\mode<presentation>{}
\usetheme{Madrid}
\usecolortheme{seahorse}%seagull?

%\setbeamertemplate{title page}[default][colsep=-4bp,rounded=true] %Remove drop shadow on title page box
%\setbeamertemplate{frametitle}[default][center] %Centre the titles of frames

\usepackage[T1]{fontenc}
\usepackage{lmodern} %Makes \textasciitilde not raised.
\usepackage{inconsolata} %A nice monospace font
\newcommand\hyphen{\char`\-}
\newcommand\textasciicaret{\textasciicircum}

\usepackage{siunitx}

\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows.meta,calc,backgrounds,intersections,shapes}

\usepackage{caption}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	urlcolor=blue,
}
\urlstyle{same} %URLs are set in the font of the surrounding text

\usepackage{listings}

%\definecolor{GoodGreen}{RGB}{0,140,0}

\graphicspath{{./images/}}

\renewcommand\emph[1]{\textbf{#1}}

\title[Command Line \& Shell]{The Command Line, Shell and Shell Scripting}
%\subtitle{\vspace{2mm}\small{
%	based upon the paper\\
%	\emph{Genomic linkage of male song and female acoustic preference QTL underlying a rapid species radiation}\\
%	by K.\ Shaw and S.\ Lesnick (2009)\\
%	in \textit{PNAS}
%}}
\author{Christopher Brown}
\date{}

\begin{document}

\lstset{aboveskip=0pt, belowskip=0pt} %Remove the extra space in listings.

% title frame
\begin{frame}
	\titlepage
\end{frame}

\section{Introduction}

\begin{frame}{What is the Shell?}
	\begin{columns}[t]
	\column{0.5\textwidth}
		\colorlet{shellcol2}{black!30}
		\colorlet{shellcol1}{white}
		\begin{tikzpicture}
			%Circles
			\draw [fill=shellcol2] (0,0) circle (3.5);
			\draw [fill=shellcol1] (0,0) circle (2.5);
			\draw [fill=shellcol2] (0,0) circle (1.5);
			%Labels
			\node at (0,2.95) {Shell};
			\node at (0,1.9) {Kernel};
			\node at (0,0) {Hardware};
		\end{tikzpicture}
	\column{0.3\textwidth}
		Interface between user and operating system kernel.
	\end{columns}
	\note{
		Being replaced by Graphical User Interfaces more these days.
	}
\end{frame}

\begin{frame}{Why Shell?}
	\begin{itemize}
		\item Automisation
		\item Reproducibility
		\item Scripting
		\begin{itemize}
			\item Call other programs
			\item Manipulate files
			\item String utilities
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Which Shell?}
	\begin{itemize}
		\item \texttt{sh}: the Bourne Shell by Stephen Bourne, 1977
		\item \texttt{bash}: the Bourne Again SHell, 1989
		\item \texttt{zsh}, \texttt{ksh}, \texttt{tcsh}, \texttt{rc}\dots
	\end{itemize}
	We will use \texttt{bash}.
	
	Default on most Linux distros and Mac OS X.
	
	On Windows via Cygwin or WSL.
\end{frame}

\section{Basic Commands}

\begin{frame}{UNIX Directories}
	\begin{itemize}
		\item \texttt{/} is the root directory
		\item \texttt{\textasciitilde} is your user's home directory
		\begin{itemize}
			\item \texttt{/home/abc123/} on Linux
			\item \texttt{/Users/abc123/} on Mac OS X
		\end{itemize}
		\item \texttt{.} is the current directory
		\item \texttt{..} moves up one directory
	\end{itemize}
	Paths starting with \texttt{/} or \texttt{\textasciitilde} are \emph{absolute paths}.
	
	Others are \emph{relative paths}, and start from the current directory.
\end{frame}

\begin{frame}{Moving Around}
	\begin{itemize}
		\item \texttt{pwd}: Print Working Directory
		\item \texttt{cd}: Change Directory
		\begin{itemize}
			\item \texttt{cd \hyphen} goes to previous directory
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{What's Here?}
	\begin{itemize}
		\item \texttt{ls}: LiSt
		\begin{itemize}
			\item \texttt{ls \hyphen l} gives extra information
			\item \texttt{ls \hyphen a} includes hidden files/folders
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Changing Stuff}
	\begin{itemize}
		\item \texttt{mkdir}: MaKe DIRectory
		\item \texttt{rmdir}: ReMove empty DIRectory
	\end{itemize}
\end{frame}

\begin{frame}{More Changing Stuff}
	\begin{itemize}
		\item \texttt{touch}: create a blank file, change last modified date
		\item \texttt{cp}: CoPy a file/directory
		\item \texttt{mv}: MoVe/rename a file/directory
		\item \texttt{rm}: ReMove a file
		\begin{itemize}
			\item \texttt{rm \hyphen i} asks confirmation: safer
			\item \texttt{rm \hyphen r} removes a directory and everything inside
		\end{itemize}
	\end{itemize}
	\note{
		There is no trash for \texttt{rm}!
	}
\end{frame}

\begin{frame}{Viewing Files}
	\begin{itemize}
		\item \texttt{cat}: print a file, or conCATenate several
		\item \texttt{head}: print the first 10 lines of a file
		\item \texttt{tail}: print the last 10 lines of a file
		\item \texttt{more}: view a file interactively
		\item \texttt{less}: \texttt{more}, but better
	\end{itemize}
	\note{
		There is no trash for \texttt{rm}!
	}
\end{frame}

\begin{frame}{Printing Stuff}
	\begin{itemize}
		\item \texttt{echo}: print arguments
	\end{itemize}
\end{frame}

\begin{frame}{Text Editors}
	\begin{itemize}
		\item \texttt{nano}: simple, useful for quick stuff
		\begin{itemize}
			\item \texttt{\textasciicaret S} to save
			\item \texttt{\textasciicaret X} to exit
		\end{itemize}
		\item \texttt{vim}, \texttt{emacs}: complicated \& super powerful
	\end{itemize}
\end{frame}

\section{How Stuff Works}

\begin{frame}{Structure of a Command}
	\texttt{command argument1 argument2 \dots}
	\begin{itemize}
		\item \texttt{mv misspelled.csv spelled.csv}
	\end{itemize}
	
	Arguments with spaces need quotes.
	\begin{itemize}
		\item \texttt{mv 'Old File.txt' 'New File.txt'}
	\end{itemize}
	\note{
		Many commands can take different numbers of arguments.
	}
\end{frame}

\begin{frame}{Options}
	Options can normally be mixed with arguments.
	
	Short options start with a dash and are one character.
	\begin{itemize}
		\item \texttt{rm \hyphen r examples/}
		\item \texttt{rm examples/ \hyphen r}
	\end{itemize}
	
	Long options start with two dashes and are multiple characters.
	\begin{itemize}
		\item \texttt{rm \hyphen\hyphen recursive examples/}
		\item \texttt{rm examples/ \hyphen\hyphen recursive}
	\end{itemize}
	
	Some nasty commands (\texttt{find}) have long options with one dash.
\end{frame}

\begin{frame}{More Options}
	Short options can be combined. The following are the same:
	\begin{itemize}
		\item \texttt{grep \hyphen r \hyphen F \hyphen i "vegetable"}
		\item \texttt{grep \hyphen rFi "vegetable"}
	\end{itemize}
	Some options take their own arguments.
	\begin{itemize}
		\item \texttt{head data.csv \hyphen n5}
		\item \texttt{head data.csv \hyphen n 5}
		\item \texttt{head data.csv \hyphen\hyphen lines 5}
	\end{itemize}
\end{frame}

\begin{frame}{Getting Help}
	Use the MANual, \texttt{man}:
	\begin{itemize}
		\item \texttt{man ls}
	\end{itemize}
	Many commands have their own help.
	\begin{itemize}
		\item \texttt{ls --help}
	\end{itemize}
	Search man pages using \texttt{/}
\end{frame}

\begin{frame}{Interlude}
	Poke around the \texttt{man} pages of some of the commands we've used. Look for helpful options.
	
	We'll start scripting next!
\end{frame}

\section{Scripting}

\begin{frame}{Scripting}
	We can use shell as a programming language.
	
	Let's use it to write an example program.
	
	We want to download a news article from the internet.
\end{frame}

\begin{frame}{Let's Make Things More Fun}
	\begin{figure}
		\includegraphics[height=0.7\textheight]{substitutions}
	\end{figure}
	``xkcd'' by Randall Munroe
\end{frame}

\begin{frame}{What Do We Need To Do?}
	\begin{itemize}
		\item Get the URL from the command line arguments.
		\item Get the output filename from the arguments.
		\item Download the webpage.
		\item Perform the substititions.
	\end{itemize}
\end{frame}

\begin{frame}{Shebang!}
	The computer needs to know our script is a shell script.
	Is it \texttt{bash}, \texttt{python}, \texttt{R}?
	
	We use a shebang: \texttt{\#!}
	
	This goes on the first line, then the interpreter to run the program.
	\begin{itemize}
		\item \texttt{\#!/bin/bash}
		\item \texttt{\#!/usr/bin/env Rscript}
		\item \texttt{\#!/usr/bin/env python3}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Simple Script}
	\begin{verbatim}
		#!/bin/bash
		
		echo "Usage: news URL OUTFILE"
	\end{verbatim}
\end{frame}

\begin{frame}{Running the Script}
	\texttt{./news}
	
	But we need to set the permissions, as it is not exectable.
	
	\texttt{chmod}: CHange MODe
	\begin{itemize}
		\item \texttt{chmod u+x news}
	\end{itemize}
	Adds eXecute permission for the User.
	\begin{itemize}
		\item User, Group, Other
		\item Read, Write, eXecute
	\end{itemize}
	\texttt{chmod -w} is good for protecting data.
	\note{
		\texttt{ls \hyphen l}
	}
\end{frame}

\section{Variables}

\begin{frame}{Variables}
	Programming's no good without variables.
	Shell's variables are all strings.
	
	Assign with \texttt{=}, no spaces!
	\begin{itemize}
		\item \texttt{foo=sometext}
		\item \texttt{bar="Some Text"}
	\end{itemize}
	Access with \texttt{\$}.
	\begin{itemize}
		\item \texttt{echo \$foo}
		\item \texttt{echo \$bar}
	\end{itemize}
	\note{
		Accessed variables are treated just like code.
	}
\end{frame}

\begin{frame}{Quoting}
	Variables are expanded inside double quotes, but not single.
	\begin{itemize}
		\item \texttt{echo '\$foo'}
		\item \texttt{echo "\$foo"}
	\end{itemize}
	Use quotes to keep things quoted.
	\begin{itemize}
		\item \texttt{bar="Some\ \ \ \ Text"}
		\item \texttt{echo \$bar}
		\item \texttt{echo "\$bar"}
	\end{itemize}
\end{frame}

\begin{frame}{Command Line Arguments}
	Arguments to your script are in variables.
	\begin{itemize}
		\item \texttt{\$0}: the command itself
		\item \texttt{\$1}: the first argument
		\item \texttt{\$2}: the second argument
		\item \texttt{\$\#}: the number of arguments (excludes \texttt{\$0})
		\item \texttt{"\$@"}: all the arguments (quote it!)
	\end{itemize}
\end{frame}

\begin{frame}{Types of Variable}
	\texttt{readonly} variables can't be changed later.
	\begin{itemize}
		\item \texttt{readonly blah="Can't touch this"}
	\end{itemize}
	\texttt{export} variables to make them visible to programs you call.
	\begin{itemize}
		\item \texttt{export GSL\_RNG\_SEED=42}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Variables in the Script}
	\begin{verbatim}
		#!/bin/bash
		
		readonly usage="Usage: news URL OUTFILE"
		
		url="$1"
		outfile="$2"
		
		echo "$usage"
	\end{verbatim}
\end{frame}

\section{Flow Control}

\begin{frame}{Flow Control}
	Programming also needs conditionals (\texttt{if}) and loops (\texttt{while}, \texttt{for}).
	
	But first, we need return values.
	\begin{itemize}
		\item \texttt{\$?}: the return value of the last command
		\item 0 is success
		\item Anything else is failure
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Conditionals}
	\texttt{if} executes if the command succeeds, and not otherwise.
	\begin{verbatim}
		if command
		then
		    ...
		fi
	\end{verbatim}
\end{frame}

\begin{frame}[fragile]{More Conditionals}
	It can be accompanied by \texttt{elif} and \texttt{else}.
	\begin{verbatim}
		if command; then
		    ...
		elif command; then
		    ...
		else
		    ...
		fi
	\end{verbatim}
\end{frame}

\begin{frame}{Testing}
	\texttt{test} is designed for \texttt{if}.
	\begin{itemize}
		\item \texttt{test blah = blah}
		\item \texttt{test 2 \hyphen eq 3}
		\item \texttt{test ! horse = dog}
	\end{itemize}
	
	\texttt{[} is another form of \texttt{test}. The last argument must be \texttt{]}.
	\begin{itemize}
		\item \texttt{[ 2 \hyphen eq 3}
		\item \texttt{[ 2 \hyphen eq 3 ]}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Loops}
	\begin{verbatim}
		while command
		do
		    ...
		done
	\end{verbatim}
\end{frame}

\begin{frame}[fragile]{A While Loop}
	\begin{verbatim}
		while [ "$foo" != aaaaaaa ]; do
		    echo "$foo"
		    foo="a$foo"
		done
	\end{verbatim}
\end{frame}

\begin{frame}[fragile]{More Loops}
	\begin{verbatim}
		for variable in string1 string2 string3
		do
		    ...
		done
	\end{verbatim}
\end{frame}

\begin{frame}[fragile]{A For Loop}
	\begin{verbatim}
		for name in John Mary Poppy; do
		    echo "Hello $name"
		done
	\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Range Notation}
	\begin{verbatim}
		for i in {1..5}; do
		    echo "Iteration $i"
		done
	\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Conditionals in the Script}
	\begin{verbatim}
		#!/bin/bash
		
		readonly usage="Usage: news URL OUTFILE"
		
		if [ $# -ne 2 ]; then
		    echo "$usage"
		    exit 1
		fi
		
		url="$1"
		outfile="$2"
		
		echo Working
	\end{verbatim}
\end{frame}

\section{Miscellaneous}

\begin{frame}{Globbing}
	The shell expands wildcards for us.
	\begin{itemize}
		\item \texttt{echo *.txt}
		\item \texttt{echo '*.txt'}
		\item \texttt{echo "*.txt"}
		\item \texttt{echo *'.txt'}
		\item \texttt{echo *".txt"}
	\end{itemize}
	The shell does this itself, not our program.
\end{frame}

\begin{frame}[fragile]{Command Substitution}
	Command substitution makes output from a command into shell text.
	\begin{itemize}
		\item \texttt{foo=\$(ls)}
		\item \texttt{bar=\$(cat slides.tex)}
	\end{itemize}
	\begin{verbatim}
		for file in $(ls); do
		    echo "File: $file"
		done
	\end{verbatim}
\end{frame}

\end{document}
